#!/usr/bin/env perl

use strict;
use warnings;

@ARGV == 3 or die "Usage: $0 <templates.fasta> <exclude template id.txt> <probes_and_or_primers.fasta>\n";
my $db_file = shift @ARGV;
my $excludes_file = shift @ARGV;
my $query_file = shift @ARGV;

if(not -e "$db_file.nsq" or -M "$db_file.nsq" > -M $db_file){ # non-existent or older BLAST index for the FastA file of templates
	warn "Creating new BLAST database\n";
	system("makeblastdb -in $db_file -dbtype nucl 1>&2") >> 8 
	  and die "Cannot run makeblastdb, return code $?\n";
}

# List of template se quence identifiers to exclude from the mismatch analysis due to duplication, poor quality, etc.
open(EXCLUDES, $excludes_file)
  or die "Cannot open excluded IDs file $excludes_file for reading: $!\n";
my %exclude;
while(<EXCLUDES>){
	next if /^\s*#/;
	if(/^(\S+)/){
		$exclude{$1} = 1;
	}
}
close(EXCLUDES);

# Track all of the relevant templates and queries as we will need this data later for extending the alignments and calculating ambiguity matches
$/ = "\n>"; # FastA record separator
open(QUERIES, $query_file)
  or die "Cannot open $query_file for reading: $!\n";
my %query_sequences;
my $shortest_query_len = 10000000;
while(<QUERIES>){
	my ($query_name, $query_sequence) = /^>?(\S+).*?\n(.*)/;
	$query_sequence =~ tr/ \t\r\n//d;
	$query_sequences{$query_name} = $query_sequence;
	if(length($query_sequence) < $shortest_query_len){
		$shortest_query_len = length($query_sequence);
	}
}
close(QUERIES);
# 4 is the smallest word size supported by BLAST 2.9.0+
my $blastn_word_size = 4;
my $min_interferring_N_stretch = $shortest_query_len - 2*$blastn_word_size;

open(TEMPLATES, $db_file)
  or die "Cannot open templates sequence file $db_file for reading: $!\n";
my %template_sequences;
my %template_sequence_N_regions;
while(<TEMPLATES>){
	my ($template_name, $template_sequence) = /^>?(\S+).*?\n(.*)/;
	my $template_name_prefix = $template_name;
	$template_name_prefix =~ s/\|.*//;
	$template_name_prefix =~ s/hCoV-19\///; # GISAID-NextStrain specific ID hacks
	if(defined $exclude{$template_name_prefix}){
		# augment excludes list with the full unadulterated name of the template sequence as will be reported by BLASTN
		$exclude{$template_name} = 1; 
		#warn "Excluding $template_name_prefix\n";
		next;
	}
	$template_sequence =~ tr/ \t\r\n//d;
	$template_sequence = uc($template_sequence); # upper case
	$template_sequences{$template_name} = $template_sequence;

	# Let's record as linear coordinate tuples where stretches of N's are located in the genome, so these
	# can be reported to help the user determine if a lack of BLAST match is due to change in the sequence,
	# or that it's N's where the primer/probe would normally bind.
	while($template_sequence =~ /N{$min_interferring_N_stretch,}/go){
		$template_sequence_N_regions{$template_name} //= []; # eschewing auto-vivification of the array
		push @{$template_sequence_N_regions{$template_name}}, [pos($template_sequence), pos($template_sequence)+length($&)-1];
	}
}
close(TEMPLATES);

my $num_templates = scalar(keys %template_sequences);
open(BLAST, "blastn -max_target_seqs $num_templates -word_size $blastn_word_size -db $db_file -query $query_file -dust no -soft_masking false -evalue 1000 |")
  or die "Cannot run blastn: $!\n";
$/ = "\nQuery="; # BLAST query output separator
my %mismatch_alignments;
my %perfect_match_alignment;
my %query_lengths;
my %extended_alignment;
while(<BLAST>){
	if(not /(?:Query=)?\s*(\S+)\s+Length=(\d+)/s){
		next; # prologue
	}
	my ($query_name, $query_length) = ($1, $2);
	# Sanity check of earlier sequence parsing
	if(not exists $query_sequences{$query_name}){
		die "Discrepancy between query lists when parsed by this script and NCBI BLAST, please check FastA formatting of entry '$query_name'\n";
	}
	if($query_length != length($query_sequences{$query_name})){
		die "Discrepancy between length of query when parsed by this script and NCBI BLAST, please check FastA formatting of entry '$query_name'\n";
	}
	$query_lengths{$query_name} = $query_length;
	my @hits = split /\n>/s, $_;
	shift @hits; # alignment summary header

	while(@hits){
		my $hit = shift @hits;
		my ($subject_name, $alignments) = $hit =~ /^(\S+)\nLength=\d+\s+(.*)/s;
		next if $exclude{$subject_name};
		my ($identities) = $hit =~ /Identities = (\d+)/;
		if($hit =~ /Identities = \d+\/(\d+) \(100%/s and $1 == $query_length and $hit =~ /Gaps = 0/){
			$perfect_match_alignment{$subject_name}->{$query_name} = 1;
			next; # perfect match, no need to record
		}
		# Discount mismatches if they match a suitable IUPAC ambiguity code
		#my ($qstart, $qaln, $qend, $sstart, $saln, $send) = $hit =~ /Query\s+(\d+)\s+(\S+)\s+(\d+).*?Sbjct\s+(\d+)\s+(\S+)\s+(\d+)/s;
		my ($qstart, $qpad, $qaln, $qend, $aln, $sstart, $spad, $saln, $send) = $hit =~ /Query\s+(\d+)(\s+)(\S+)\s+(\d+)\s+?       ([^\n]+)\s+?Sbjct\s+(\d+)(\s+)(\S+)\s+(\d+)/s;

		# If the match is a substring of the query, extend the alignment in both the query and subject so the user sees the terminal mismatches
		# Use lower case letters to indicate that we added these bits.
		my $five_prime_subject = lc(substr($template_sequences{$subject_name}, $sstart-$qstart, $qstart-1));
		my $three_prime_subject = lc(substr($template_sequences{$subject_name}, $send, $query_length-$qend));
		my $five_prime_query = lc(substr($query_sequences{$query_name}, 0, $qstart-1));
		my $three_prime_query = $qend == $query_length ? "" : lc(substr($query_sequences{$query_name}, $qend));
		if($qstart > 1){
			$aln =~ s/^(\s+)/$1.(" " x ($qstart-1))/e;
		}
		if($qend != $query_length || $qstart > 1){
			$extended_alignment{$subject_name} //= 1;
		}
		if(&valid_iupac_substitution($five_prime_query,$five_prime_subject) && 
                   &valid_iupac_substitution($three_prime_query,$three_prime_subject) && 
		   &valid_iupac_substitution($qaln,$saln)){
			# ignore as perfect match since truncated alignment is only due to ambiguous bases in the template
			$perfect_match_alignment{$subject_name}->{$query_name} = 1;
			next;
		}
		$saln = $five_prime_subject.$saln.$three_prime_subject;
		$qaln = $five_prime_query.$qaln.$three_prime_query;
		$mismatch_alignments{$subject_name} //= {};
		$mismatch_alignments{$subject_name}->{$query_name} = "BLAST exact matches: $identities/$query_length\n$qstart$qpad$qaln $qend\n$aln\n$sstart$spad$saln $send\n";
	}
	
}
close(BLAST);
for my $subject_name (sort keys %template_sequences){
	next if $exclude{$subject_name};
	my $num_mismatch_hits = 0;
	my $num_no_hits = 0;
	my $text = "";
	for my $query_name (sort keys %query_lengths){
		if(exists $mismatch_alignments{$subject_name} and exists $mismatch_alignments{$subject_name}->{$query_name}){
			$text .= "Mismatch against $query_name with ". $mismatch_alignments{$subject_name}->{$query_name}."\n";
			$num_mismatch_hits++;
		}
		elsif(not exists $perfect_match_alignment{$subject_name} or not exists $perfect_match_alignment{$subject_name}->{$query_name}){
			$text .= "NO MATCH FOUND for $query_name (length $query_lengths{$query_name})\n";
			$num_no_hits++;
		}
	}
	if($num_mismatch_hits or $num_no_hits){
		print "===$subject_name===\n";
		if($num_no_hits or exists $extended_alignment{$subject_name}){
			# Print information about template length and the location of stretches of N's that might be relevant to doing triage of misses
			print "Template length ", length($template_sequences{$subject_name}),", N stretches: [", join("], [", map {$_->[0].",".$_->[1]} @{$template_sequence_N_regions{$subject_name}}), "]\n";
		}
		print $text;
	}
}

sub valid_iupac_substitution{
	my ($qry, $sbjt) = @_;
	
	if(length($qry) == 0 and length($sbjt)){
		return 1;
	}

	my %subs = (
		A => "[ARWNMDHV]",
		C => "[CYSNMBHV]",
		G => "[GRSNKBDV]",
		T => "[TYWNKBDH]",
		R => "[AGN]",
		Y => "[CTN]",
		S => "[CGN]",
		W => "[ATN]",
		K => "[GTN]",
		M => "[ACN]",
		B => "[CGTN]",
		D => "[AGTN]",
		H => "[ACTN]",
		V => "[ACGN]",
		N => "[NACGTRYSWKMBDHV]"
		);
	$subs{"U"} = $subs{"T"}; # support RNA
	$subs{"-"} = "-"; # support gaps

	# asking for substring match
	my $regex = "";
	for(my $i = 0; $i < length($qry); $i++){
		my $rchar = uc(substr($qry, $i, 1)); # convert to upper case
		warn "Check query FastA, a non-IUPAC nucleotide letter found was found: $rchar\n" if not exists $subs{$rchar};
		$regex .= $subs{$rchar};
	}
	return uc($sbjt) =~ /^$regex$/;
}
